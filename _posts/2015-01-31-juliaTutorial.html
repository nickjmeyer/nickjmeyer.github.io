---
layout: post
title: Julia - A Brief Introduction
---


<p>
Declaring variables
</p>
<div class="org-src-container">

<pre class="src src-julia">x = 0
y = 1
</pre>
</div>

<pre class="example">
0
1
</pre>

<p>
In an interactive session, we can see Julia prints the output.  If we
want to suppress output, we can append a semicolon.
</p>

<div class="org-src-container">

<pre class="src src-julia">x = 0; <span style="color: #ff0000;">## </span><span style="color: #ff0000;">does not produce output</span>
</pre>
</div>

<p>
Two ways of displaying output are the <code>show</code> and
<code>print</code> commands.
</p>


<p>
Arithmetic
</p>
<div class="org-src-container">

<pre class="src src-julia">x = 4;
y = 12;

x + y
x - y
x * y
x / y <span style="color: #ff0000;">## </span><span style="color: #ff0000;">x divided by y</span>
x \ y <span style="color: #ff0000;">## </span><span style="color: #ff0000;">y divided by x</span>
y % x <span style="color: #ff0000;">## </span><span style="color: #ff0000;">y modulos x</span>
y ^ x
</pre>
</div>

<pre class="example">
16
-8
48
0.3333333333333333
3.0
0
20736
</pre>

<p>
The second to last result as a decimal is <code>0.3333...</code>.  Storing this as a
floating point number is impossible, but this is a rational number.
Julia has a built-in type for rationals.  By using the <code>//</code>
operator, the return value is a rational type.
</p>

<div class="org-src-container">

<pre class="src src-julia">r=x//y
<span style="color: #4169e1;">convert</span>(<span style="color: #32cd32;">Float64</span>,r)
</pre>
</div>

<pre class="example">
1//3
0.3333333333333333
</pre>

<p>
Behind the scenes, the rational number type is simply stored as two
integers.  This can be seen using <code>help</code>.
</p>

<div class="org-src-container">

<pre class="src src-julia"><span style="color: #4169e1;">help</span>(r)
<span style="color: #4169e1;">help</span>(r.num)
<span style="color: #4169e1;">help</span>(r.den)
</pre>
</div>

<pre class="example">
1//3 is of type
DataType   : Rational{Int64} (constructor with 1 method)
  supertype: Real
  fields   : (:num,:den)
1 is of type
DataType   : Int64
  supertype: Signed
3 is of type
DataType   : Int64
  supertype: Signed
</pre>


<p>
Lets, define our own class.  This class will be based on modular arithmetic.
</p>

<div class="org-src-container">

<pre class="src src-julia"><span style="color: #daa520;">type</span> ModType{n}
    x::<span style="color: #32cd32;">Int</span>
    <span style="color: #4169e1;">ModeType</span>(x::<span style="color: #32cd32;">Int</span>) = <span style="color: #4169e1;">new</span>(<span style="color: #4169e1;">mod</span>(x,n))
<span style="color: #daa520;">end</span>

x=ModType{2}(6)
<span style="color: #4169e1;">print</span>(x)
</pre>
</div>

<pre class="example">
ERROR: invalid redefinition of constant ModType

ERROR: `ModType{2}` has no method matching ModType{2}(::Int64)
4
</pre>


<div class="org-src-container">

<pre class="src src-julia"><span style="color: #4169e1;">print</span>(1:5,<span style="color: #ff7f00;">"\n"</span>)
<span style="color: #4169e1;">print</span>([i <span style="color: #daa520;">for</span> i=1:5],<span style="color: #ff7f00;">"\n"</span>)
<span style="color: #4169e1;">print</span>([<span style="color: #4169e1;">trace</span>(<span style="color: #4169e1;">rand</span>(n,n)) <span style="color: #daa520;">for</span> n=1:5],<span style="color: #ff7f00;">"\n"</span>)
</pre>
</div>

<pre class="example">
1:5
[1,2,3,4,5]
[0.9092715015802453,0.35403646997092175,1.8104065247324423,2.4686870803447425,2.8744840061499914]
</pre>
